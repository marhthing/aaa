
# WhatsApp Bot Development Project

## AI Development Prompt

Please help me build a professional WhatsApp bot with the following specifications and architecture:

### 🎯 Project Overview
Create a modular, scalable WhatsApp bot using Node.js with the following core features:
- Multi-session support for multiple WhatsApp accounts
- Plugin-based architecture for easy feature extension
- Multi-language support with JSON language files
- Clean separation of concerns with organized folder structure
- Environment-based configuration management
- Database integration for persistent data storage

### 📁 Required Folder Structure
```
whatsapp-bot/
├── lib/                    # Core library files
│   ├── class/             # Main classes (Message, Bot, etc.)
│   ├── db/                # Database models and handlers
│   ├── utils/             # Utility functions
│   └── handlers/          # Event and message handlers
├── plugins/               # Feature plugins (modular)
├── lang/                  # Language JSON files
├── media/                 # Static media files
├── config/                # Configuration files
├── logs/                  # Application logs
├── index.js              # Main entry point
├── config.js             # Configuration loader
└── package.json          # Dependencies
```

### 🏗️ Core Architecture Requirements

#### 1. Main Classes Structure
- **Bot Class**: Main bot initialization and connection management
- **Message Class**: Handle incoming messages with reply capabilities  
- **Command Class**: Command registration and execution system
- **Database Class**: Handle all database operations
- **Plugin Class**: Dynamic plugin loading and management

#### 2. Configuration System
- Environment variables support via `.env` file
- Configuration validation and defaults
- Support for multiple deployment environments (development, production)
- Key configurations needed:
  ```
  SESSION_ID, PREFIX, BOT_LANG, SUDO_USERS, DATABASE_URL,
  AUTO_READ, AUTO_ONLINE, REJECT_CALLS, LOG_LEVEL
  ```

#### 3. Database Integration
- Use Sequelize ORM for database operations
- Support both SQLite (development) and PostgreSQL (production)
- Required tables: sessions, users, groups, settings, logs
- Migration system for database updates

#### 4. Plugin System
- Each plugin in separate file in `/plugins` folder
- Plugin registration system with metadata
- Command registration within plugins
- Plugin enable/disable functionality
- Hot-reload capability for development

#### 5. Multi-Language Support
- JSON files for each language in `/lang` folder
- Dynamic language switching per user
- Fallback to default language if translation missing
- Support for: English, Spanish, Hindi, Arabic, French

### 🔧 Essential Features to Implement

#### Core Bot Features:
1. **Session Management**: Save and restore WhatsApp sessions
2. **Command System**: Prefix-based commands with help system
3. **Auto-Reply**: Automated responses and greetings
4. **Media Handling**: Send/receive images, videos, audio, documents
5. **Group Management**: Admin controls, member management
6. **User Management**: User registration, preferences, permissions

#### Admin Features:
1. **Sudo System**: Admin-only commands and privileges
2. **Plugin Management**: Enable/disable plugins remotely
3. **Settings Management**: Change bot configuration via commands
4. **Logging System**: Comprehensive logging with levels
5. **Backup/Restore**: Database and session backup functionality

#### Utility Features:
1. **Status Management**: Auto-read messages, always online
2. **Anti-Spam**: Rate limiting and spam detection
3. **Scheduled Messages**: Send messages at specific times
4. **Broadcast**: Send messages to multiple contacts/groups

### 📦 Required Dependencies
```json
{
  "dependencies": {
    "@whiskeysockets/baileys": "latest",
    "sequelize": "^6.32.1",
    "sqlite3": "^5.1.6",
    "pg": "^8.11.3",
    "dotenv": "^16.3.1",
    "moment": "^2.29.4",
    "axios": "^1.5.0",
    "fs-extra": "^11.1.1",
    "qrcode-terminal": "^0.12.0",
    "winston": "^3.10.0"
  }
}
```

### 🚀 Implementation Guidelines

#### Code Quality Standards:
- Use ES6+ features and async/await
- Implement proper error handling with try-catch blocks
- Add comprehensive logging for debugging
- Use consistent naming conventions
- Add JSDoc comments for functions and classes
- Implement graceful shutdown handling

#### Security Considerations:
- Validate all user inputs
- Implement rate limiting for commands
- Secure sensitive configuration in environment variables
- Add permission checks for admin commands
- Sanitize data before database operations

#### Performance Optimization:
- Implement connection pooling for database
- Use caching for frequently accessed data
- Optimize media handling and storage
- Implement lazy loading for plugins
- Add request queuing for API calls

### 🔄 Development Workflow
1. Start with basic bot connection and message handling
2. Implement core classes and database models
3. Create plugin system and sample plugins
4. Add configuration management and environment support
5. Implement multi-language support
6. Add logging and error handling
7. Create admin features and security measures
8. Optimize performance and add monitoring

### 📋 Sample Plugin Structure
Each plugin should follow this template:
```javascript
module.exports = {
  name: 'plugin-name',
  description: 'Plugin description',
  version: '1.0.0',
  commands: ['command1', 'command2'],
  category: 'utility',
  usage: 'command [parameters]',
  async execute(bot, message, args) {
    // Plugin logic here
  }
};
```

### 🎯 Success Criteria
- Bot successfully connects to WhatsApp
- Modular plugin system working
- Database operations functioning
- Multi-language support active
- Clean, maintainable code structure
- Comprehensive error handling
- Detailed logging system
- Easy deployment and configuration

### 🎯 Key Architectural Insights from Levanter Analysis

Based on detailed analysis of the Levanter codebase, implement these critical patterns:

#### Advanced Configuration Management
- **Dual Database Strategy**: SQLite for development, PostgreSQL for production
- **Platform Detection**: Automatic detection of hosting environment (Heroku, Koyeb, VPS)
- **Environment Validation**: Robust validation with meaningful defaults
- **Runtime Configuration**: Allow configuration changes without restart

#### Plugin Architecture Best Practices
```javascript
// Each plugin should export this structure
module.exports = {
  command: ['cmd1', 'cmd2'],
  category: 'utility',
  description: 'Plugin description',
  usage: '[parameters]',
  fromMe: false, // Can be used by non-owners
  type: 'whatsapp',
  async function(message, match, client) {
    // Plugin logic with full access to message context
    // Auto-error handling and logging
    // Permission checking built-in
  }
};
```

#### Session & State Management
- **Session Persistence**: Robust session saving/restoration
- **State Synchronization**: Handle connection drops gracefully
- **Multi-device Support**: Handle multiple WhatsApp connections
- **Authentication Recovery**: Auto-reconnection with saved credentials

#### Security & Protection Systems
```javascript
// Implement these protection layers
const protectionSystems = {
  antiSpam: { maxMessages: 10, timeWindow: 60000 },
  antiLink: { enabled: true, whitelist: [], kickOffenders: true },
  antiBot: { detectBots: true, autoKick: true },
  rateLimit: { commandsPerMinute: 20, perUser: true }
};
```

#### Message Processing Pipeline
1. **Input Validation**: Sanitize all incoming messages
2. **Command Parsing**: Extract commands, parameters, and context
3. **Permission Checking**: Verify user permissions and restrictions
4. **Plugin Execution**: Route to appropriate plugin with error isolation
5. **Response Formatting**: Format and send responses with rate limiting

#### Advanced Features Implementation
- **Scheduled Messages**: Cron-based scheduling system
- **Media Processing**: Image/video/audio manipulation with FFmpeg
- **External API Integration**: Robust API calling with retry logic
- **Database Optimization**: Connection pooling and query optimization
- **Monitoring & Analytics**: Comprehensive logging and usage statistics

#### Error Handling Strategy
```javascript
// Implement comprehensive error handling
class BotError extends Error {
  constructor(message, code, recoverable = true) {
    super(message);
    this.code = code;
    this.recoverable = recoverable;
    this.timestamp = new Date();
  }
}

// Global error handlers for different scenarios
const errorHandlers = {
  connectionError: (error) => { /* Auto-reconnect logic */ },
  pluginError: (error, plugin) => { /* Isolate and log */ },
  databaseError: (error) => { /* Fallback to local storage */ },
  apiError: (error, api) => { /* Retry with backoff */ }
};
```

#### Performance Optimization Techniques
- **Lazy Loading**: Load plugins only when needed
- **Message Queuing**: Handle high-volume messaging
- **Caching Strategy**: Cache frequently accessed data
- **Memory Management**: Prevent memory leaks in long-running processes
- **Connection Pooling**: Efficient database connections

#### Production Deployment Considerations
- **Process Management**: Use PM2 for process monitoring
- **Health Checks**: Implement health monitoring endpoints
- **Graceful Shutdown**: Handle SIGTERM properly
- **Resource Monitoring**: CPU, memory, and network usage tracking
- **Automatic Updates**: Safe deployment and rollback mechanisms

### 🚀 Implementation Priority Order

1. **Phase 1**: Core connection and basic message handling
2. **Phase 2**: Configuration system and database integration
3. **Phase 3**: Plugin architecture and loader system
4. **Phase 4**: Security systems and rate limiting
5. **Phase 5**: Advanced features and optimizations
6. **Phase 6**: Monitoring, logging, and production hardening

### 🔧 Code Quality & Maintenance

- **TypeScript Integration**: Consider TypeScript for better type safety
- **Unit Testing**: Comprehensive test coverage for core functions
- **Documentation**: Auto-generated API documentation
- **Code Formatting**: Consistent code style with Prettier/ESLint
- **Git Hooks**: Pre-commit validation and testing

### 🎯 Success Metrics

- **Uptime**: 99.9% availability target
- **Response Time**: <2 seconds for command execution
- **Memory Usage**: Stable memory consumption under 500MB
- **Error Rate**: <0.1% unhandled errors
- **Plugin Performance**: Individual plugin execution tracking

### 🎮 Advanced Game System Architecture

Based on Levanter's sophisticated game handling, implement these game-specific patterns:

#### Game Session Management
```javascript
// Multi-player game session structure
const GameSession = {
  id: 'unique_game_id',
  type: 'tictactoe|wcg|wrg',
  players: [player1, player2],
  state: 'waiting|active|paused|ended',
  currentPlayer: 'player_turn_index',
  board: [], // Game-specific board state
  startTime: timestamp,
  timeLimit: seconds,
  settings: {
    maxPlayers: 2,
    turnTimeout: 60,
    difficulty: 'easy|medium|hard'
  }
};
```

#### Real-Time Game Engine
```javascript
const GameEngine = {
  // Session persistence across connections
  sessions: new Map(),
  
  // Game state validation
  validateMove: (gameId, playerId, move) => {
    // Validate player turn, move legality, game state
  },
  
  // Turn-based gameplay
  processTurn: async (gameId, playerId, action) => {
    // Update game state, check win conditions, notify players
  },
  
  // Automatic cleanup
  cleanupExpiredGames: () => {
    // Remove inactive games, notify disconnected players
  }
};
```

#### Game-Specific Features
- **Tic-Tac-Toe**: 3x3 grid with win condition detection
- **Word Chain Game**: Dictionary validation with chain continuation rules
- **Random Word Game**: Prompt-based word submission with scoring
- **Custom Games**: Extensible framework for new game types

#### Interactive Game Controls
```javascript
const gameCommands = {
  'game start <type>': 'Initialize new game session',
  'game join <gameId>': 'Join existing game',
  'game move <position>': 'Make game move',
  'game pause': 'Pause current game',
  'game resume': 'Resume paused game',
  'game quit': 'Leave current game',
  'game stats': 'Show player statistics'
};
```

#### Database Schema for Games
```sql
-- Game sessions table
CREATE TABLE game_sessions (
  id VARCHAR PRIMARY KEY,
  type VARCHAR NOT NULL,
  players JSON NOT NULL,
  state VARCHAR DEFAULT 'waiting',
  board_state JSON,
  current_player INTEGER,
  created_at TIMESTAMP,
  updated_at TIMESTAMP
);

-- Player statistics
CREATE TABLE player_stats (
  player_id VARCHAR,
  game_type VARCHAR,
  games_played INTEGER DEFAULT 0,
  games_won INTEGER DEFAULT 0,
  total_score INTEGER DEFAULT 0,
  PRIMARY KEY (player_id, game_type)
);
```

This comprehensive game architecture ensures you build a production-ready WhatsApp bot that can scale and compete with commercial solutions like Levanter, with robust multiplayer gaming capabilities.
